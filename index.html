<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draw & Predict Digit</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for the canvas to ensure it's responsive and centered */
        canvas {
            border: 2px solid #3b82f6; /* Blue border */
            cursor: crosshair;
            touch-action: none; /* Prevent scrolling/zooming on touch devices */
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen flex flex-col items-center justify-center p-4">

    <div class="bg-white rounded-xl shadow-2xl p-8 max-w-lg w-full text-center space-y-6">
        <h1 class="text-4xl font-extrabold text-gray-800 mb-6">Draw a Digit</h1>

        <div class="flex flex-col items-center justify-center space-y-4">
            <canvas id="drawingCanvas" width="280" height="280" class="rounded-lg bg-gray-900"></canvas>
            <div class="flex space-x-4">
                <button id="clearBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
                    Clear
                </button>
                <button id="predictBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
                    Predict
                </button>
            </div>
            <div id="predictionResult" class="mt-6 text-3xl font-semibold text-gray-700">
                Prediction: <span id="predictedDigit" class="text-indigo-600">?</span>
            </div>
            <div id="messageBox" class="mt-4 p-3 bg-yellow-100 text-yellow-800 rounded-lg hidden"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const clearBtn = document.getElementById('clearBtn');
        const predictBtn = document.getElementById('predictBtn');
        const predictedDigitSpan = document.getElementById('predictedDigit');
        const messageBox = document.getElementById('messageBox');

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Set drawing properties
        ctx.lineWidth = 20; // Thicker line for digit drawing
        ctx.lineCap = 'round';
        ctx.strokeStyle = '#FFFFFF'; // White color for drawing on black background

        // Function to show messages
        function showMessage(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.className = `mt-4 p-3 rounded-lg ${type === 'error' ? 'bg-red-100 text-red-800' : 'bg-yellow-100 text-yellow-800'}`;
            messageBox.classList.remove('hidden');
        }

        // Function to hide messages
        function hideMessageBox() {
            messageBox.classList.add('hidden');
        }

        // Function to clear the canvas
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Re-fill with black background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            predictedDigitSpan.textContent = '?';
            hideMessageBox();
        }

        // Initial canvas setup (fill with black)
        clearCanvas();

        // Drawing functions
        function draw(e) {
            if (!isDrawing) return;
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        // Event Listeners for Mouse
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
            hideMessageBox();
        });
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseout', () => isDrawing = false);

        // Event Listeners for Touch (for mobile responsiveness)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling
            isDrawing = true;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            lastX = touch.clientX - rect.left;
            lastY = touch.clientY - rect.top;
            hideMessageBox();
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling
            if (!isDrawing) return;
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const currentX = touch.clientX - rect.left;
            const currentY = touch.clientY - rect.top;

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();
            [lastX, lastY] = [currentX, currentY];
        });

        canvas.addEventListener('touchend', () => isDrawing = false);
        canvas.addEventListener('touchcancel', () => isDrawing = false);


        // Clear button event listener
        clearBtn.addEventListener('click', clearCanvas);

        // Predict button event listener
        predictBtn.addEventListener('click', async () => {
            hideMessageBox();
            predictedDigitSpan.textContent = '...'; // Show loading indicator

            // Get image data from canvas as a PNG base64 string
            const imageData = canvas.toDataURL('image/png');

            try {
                const response = await fetch('/predict', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ image: imageData }),
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                if (result.prediction !== undefined) {
                    predictedDigitSpan.textContent = result.prediction;
                } else if (result.error) {
                    showMessage(`Error: ${result.error}`, 'error');
                    predictedDigitSpan.textContent = '?';
                } else {
                    showMessage('Unexpected response from server.', 'error');
                    predictedDigitSpan.textContent = '?';
                }
            } catch (error) {
                console.error('Prediction failed:', error);
                showMessage(`Failed to get prediction: ${error.message}`, 'error');
                predictedDigitSpan.textContent = '?';
            }
        });

        // Handle canvas resizing for responsiveness
        function resizeCanvas() {
            // Get the actual display size of the canvas element
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;

            // Check if the canvas size needs to be updated
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                ctx.putImageData(imageData, 0, 0);
                // Redraw content if necessary, or clear and re-prompt user
                // For a drawing app, it's usually better to clear and let user redraw
                clearCanvas();
            }
        }

        // Initial resize and add event listener
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Call once to set initial size

    </script>
</body>
</html>
